/* 
  Nuclear Localization Analysis in Muscle Cross-Sectional Area
  
  ImageJ macro written by Wei-Chen CHU
  Imaging Core Facility, ICOB, Academia Sinica
  Last updated: 2025/08/13
  
  Input file: raw imag mask.png generated from cellpose
  
  Note: batch command for the cellpose
  python -m cellpose --dir Analysis_folder --pretrained_model cyto2 --diameter 100. --verbose --save_png --no_npy
  
  Note: Cyto2 or Cyto3 works well, but CPSAM not
  
  Require plugin install: CLIJ/CLIJ2, 
  Please cite reference: fiji, cellpose, clij/clij2
   
 */

//Parameters
#@ String(choices={".tif", ".jpg"}, style="radioButtonHorizontal") format
#@ File (label="Folder for input", style="directory") Analysis_Folder
#@ File (label="Folder for output", style="directory") Result_Output
#@ Double(label = "Pixel_scale_X", value=0.276546388864517) scale_X
#@ Double(label = "Pixel_scale_y", value=0.27816504240036) scale_Y
#@ Integer(label = "CSA minimum size in pixel", value=2000) CSA_minimum_size
#@ Integer(label = "CSA maximum size in pixel", value=9999999) CSA_maximum_size
#@ Integer(label = "CSA edge-to-center distance", value=15) Erode_Number_radius
#@ Integer(label = "Drawing line width", value = 5) line_width


//Correction of Scale Bar and set measurements
run("Set Measurements...", "area mean standard min perimeter feret's stack display Abnormal_arrayirect=None decimal=3");
run("Line Width...", "line=1");
run("Colors...", "foreground=white background=black selection=yellow");
//Analysis_Folder = getDirectory("Choose Directory for Analysis");
//Result_Output = getDirectory("Choose Directory for the Result output");
File_List = getFileList(Analysis_Folder);
Num_Files = lengthOf(File_List);
// print("\\Clear");

print (Analysis_Folder);

function scale_calibration() { 
	Stack.setUnits("um", "um", "um", "sec", "unit");
	run("Properties...", "channels=1 slices=1 frames=1 pixel_width=" + scale_X + " pixel_height=" + scale_Y);
}

// Init GPU
run("CLIJ2 Macro Extensions", "cl_device=");
Ext.CLIJ2_clear();

//Create arrays for store information
array_size = 0;
for (f=0;f<Num_Files;f++){
	if(endsWith(File_List[f], "masks.png")){
		array_size++;
		}
}

Cell_Count_array = newArray(array_size);
Abnormal_Cell_Count_array = newArray(array_size);
Normal_Cell_Count_array = newArray(array_size);
Label_array = newArray(array_size);

array_count = -1; // to match the fist row is 0

//Main image processing loop
for (f=0;f<Num_Files;f++){
	if(endsWith(File_List[f], "masks.png")) {
		array_count++; //count the numbers of images to processes
		roiManager("reset");
		run("Clear Results");
		open(Analysis_Folder + File.separator + File_List[f]);
		run("glasbey_on_dark");
		scale_calibration();
		Pixel_Num_X = getWidth();
		Pixel_Num_Y = getHeight();
		input = File_List[f];
		File_Name = File_List[f];
		Title_Length = lengthOf(File_Name);
		Main_File_Name = substring(File_Name, 0, Title_Length-4);
		Ori_File_Name = substring(File_Name, 0, Title_Length-13); //fit to the png files generated by cellpose

		//Use CLIJ2 to extract the ROI list and then filter it
		Ext.CLIJ2_pushCurrentZStack(input);
		Ext.CLIJ2_excludeLabelsOnEdges(input, input_edge_excluded);
		Ext.CLIJ2_release(input);
		Ext.CLIJ2_excludeLabelsOutsideSizeRange(input_edge_excluded, input_filtered, CSA_minimum_size, CSA_maximum_size);
		Ext.CLIJ2_release(input_edge_excluded);
		Ext.CLIJ2_pullLabelsToROIManager(input_filtered);
		Ext.CLIJ2_pull(input_filtered);
		scale_calibration();
		run("glasbey_on_dark");
		roiManager("save", Result_Output + File.separator + Main_File_Name + "_ROI_CSA.zip");
		Cell_Count = roiManager("count");
		roiManager("reset");

		Ext.CLIJ2_erodeLabels(input_filtered, center_label, Erode_Number_radius, 0);
		Ext.CLIJ2_pullLabelsToROIManager(center_label);
		roiManager("save", Result_Output+ File.separator + Main_File_Name + "_ROI_Center.zip");

		Ext.CLIJ2_release(input_filtered);
		Ext.CLIJ2_pull(center_label);
		run("glasbey_on_dark");
		Ext.CLIJ2_release(center_label);
		Ext.CLIJ2_clear();

		//Nuclei labeling, note the File_Name var changes
		//*************************************************************
		open(Analysis_Folder + File.separator + Ori_File_Name + format);
		scale_calibration();
		
		File_Name2 = getTitle();
		Title_Length = lengthOf(File_Name2);
		Main_File_Name2 = substring(File_Name2, 0, Title_Length-4);
		run("Clear Results");
		run("Colour Deconvolution", "vectors=H&E hide"); //Colour Deconvolution or Colour Dconvolution2 is fine
		close(File_Name2 + "-(Colour_3)");
		close(File_Name2 + "-(Colour_2)");
		
		//Difference of Gaussian Filter
		selectWindow(File_Name2 + "-(Colour_1)");
		run("8-bit");
		run("Invert");
		rename("Filter_Image_A");
		run("Duplicate...", "title=Filter_Image_B");
		selectWindow("Filter_Image_A");
		run("Gaussian Blur...", "sigma=2");
		selectWindow("Filter_Image_B");
		run("Gaussian Blur...", "sigma=6");
		imageCalculator("Subtract create", "Filter_Image_A","Filter_Image_B");
		close("Filter_Image_A");
		close("Filter_Image_B");
		selectWindow("Result of Filter_Image_A");
		run("Invert");

		//Create selection for the nuclei and measure
		setAutoThreshold("Default");
		rename("Nuclei_labeling");
		setOption("BlackBackground", false);
		run("Convert to Mask");
		run("Create Selection");
		
		//Central nuclei detection
		selectWindow(File_Name2);
		selectWindow("Nuclei_labeling");
		scale_calibration();
		
		run("Select None");
		saveAs("tif", Result_Output + File.separator + Main_File_Name2 + "_Nuclei");
		roiManager("show all with labels");
		roiManager("measure");
		//saveAs("Results", Result_Output + Main_File_Name2 +"_center_nuclei.csv");
		
		//Copy image for store the positional information ans visualization
		selectWindow(File_Name2);
		run("Select None");
		run("Duplicate...", "title=Muscle_Classify");
		
		//Abnormal_Label store the positional information of abnormal cells
		Abnormal_Cell_Count = 0;
		Normal_Cell_Count = 0;
		newImage("Abnormal_Label", "8-bit black", Pixel_Num_X, Pixel_Num_X, 1);
		selectWindow("Abnormal_Label");
		run("Grays");
		setForegroundColor(255, 255, 255); //important line to ensure batch processing for the final normal/abnormal label drawing
		
		for (i = 0; i < nResults; i++) {
			Nuclei_Detection = getResult("Max", i);
			if (Nuclei_Detection==255) {    //here, the result is based on the Max value of nuclei mask
				Abnormal_Cell_Count++;
				roiManager("select", i);
				run("Draw", "slice");
			}
			else {
				Normal_Cell_Count++;
			}
		}

		selectWindow(File_Name2);
		roiManager("deselect");
		roiManager("reset");
		roiManager("open", Result_Output + File.separator + Main_File_Name + "_ROI_CSA.zip");
		run("Clear Results");
		selectWindow("Abnormal_Label");
		scale_calibration();
		
		roiManager("deselect");
		roiManager("measure")

		Abnormal_array = newArray(Cell_Count);
		for (i = 0; i < Cell_Count; i++) {
			Abnormal_array[i] = getResult("Max", i);
		}

		//Output cell map for visualization
		selectWindow("Muscle_Classify");
		for (i = 0; i < Cell_Count; i++) {
			//run("Line Width...", "line=" + line_width);
			if (Abnormal_array[i]==255){
				roiManager("select", i);
				//setForegroundColor(255, 0, 0);
				//run("Draw", "slice");
				Roi.setStrokeColor("red");
				Roi.setStrokeWidth(line_width);
				roiManager("rename", i+1 +"_Abnormal");
			} else {
				roiManager("select", i);
				//setForegroundColor(0, 255, 0);
				//run("Draw", "slice");
				Roi.setStrokeColor("green");
				Roi.setStrokeWidth(line_width);
				roiManager("rename", i+1 + "_Normal");
			} 
			
			// Store in the overlay
			Overlay.addSelection();
		}

		//export final results for each image
		run("Line Width...", "line=1");
		roiManager("save", Result_Output + File.separator + Main_File_Name2 + "_ROI_Classify.zip");
		run("Select None");
		saveAs("tif", Result_Output + File.separator + Main_File_Name2 +"_Classified");

		run("Clear Results");
		selectWindow(File_Name2);
		scale_calibration();
		
		roiManager("deselect");
		roiManager("measure");
		saveAs("Results", Result_Output + File.separator  + Main_File_Name2 + "_Summary.csv");
		
		//Arrays for store the information of each image
		Label_array[array_count] = File_Name2;
		Cell_Count_array[array_count] = Cell_Count;
		Abnormal_Cell_Count_array[array_count] = Abnormal_Cell_Count;
		Normal_Cell_Count_array[array_count] = Normal_Cell_Count;
		
		/*		
		print(File_Name2);
		print("Total_cells: " + Cell_Count);
		print("Abnormal_cells: " + Abnormal_Cell_Count);
		print("Normal_cells: " + Normal_Cell_Count);
		print("==========================================================");
		selectWindow("Log");
		saveAs("txt", Result_Output + Main_File_Name2 + "_Cell_Count.txt");
		*/
		close("*");
		run("Collect Garbage");
	}
}

//export a summary of final results
run("Clear Results");
for (i = 0; i < array_count+1; i++) {
	setResult("Label", i, Label_array[i]);
	setResult("Total_Cells", i, Cell_Count_array[i]);
	setResult("Abnormal_Cells", i, Abnormal_Cell_Count_array[i]);
	setResult("Normal_cells", i, Normal_Cell_Count_array[i]);
}
saveAs("Results", Result_Output + File.separator + "Result_Summary.csv");
